*floppybackup.s
			INCLUDE	"video.i"
			INCLUDE	"vbserror.i"

HBYTESSIZE	equ	36
BLOCKSIZE	equ	(17*HBYTESSIZE)
COPOFSDELT	equ	5*BLOCKSIZE

SECTORERROR	equ		1
SUMERROR		equ		2


lib_vectsize	equ	6
lib_base	equ	-lib_vectsize

_RVOAllocUnit	equ	lib_base-(0*lib_vectsize)
_RVOFreeUnit	equ	lib_base-(1*lib_vectsize)
_RVOGetUnit	equ	lib_base-(2*lib_vectsize)
_RVOGiveUnit	equ	lib_base-(3*lib_vectsize)
_RVOGetUnitID	equ	lib_base-(4*lib_vectsize)

			
			xref		vars,_DRResource,testfloppy
			xref		waitvb,fillblock
			xref		crctab8
			
			xdef		gototrack,gotonexttrack,cleanupfloppy,initfloppy,motor,stepdelay
			xdef		_VFG_BackupFloppy,_VFG_SetBuffers
			xdef		_GetUnit,_GiveUnit
							

_VFG_BackupFloppy:
drivenr	equ		4

			move.l	drivenr(sp),d0
			movem.l	D1-D7/A0-A6,-(SP)
			lea.l		vars(PC),a6			
			lea.l		$DFF000,a5
			
			move.w	d0,d2

			bsr		initfloppy
			
			bsr		testfloppy
			move.l	d0,d3
			cmp.w		#ENODISKINDRIVE,d0
			beq		quit1
			
			st.b		d2
			bsr		motor
			move.w	#0,d2
			bsr		gototrack
									
			lea.l		trackbuffers(a6),a2
			sf			TB_SIZEOF*0+TB_valid(a2)
			sf			TB_SIZEOF*1+TB_valid(a2)
			sf			TB_SIZEOF*2+TB_valid(a2)
			sf			TB_SIZEOF*3+TB_valid(a2)
			move.w	#0,d2;		readtracknr

.nexttrack:
			bsr		testfloppy
			move.l	d0,d3
			cmp.w		#ENODISKINDRIVE,d3
			beq		.break
			btst.b	#6,$bfe001
			beq		.break

			cmp.w		#PREREAD,d2
			bne.s		.dontinstall

				clr.w		dumptracknr(a6)

				lea.l		trackbuffers(a6),a0
				move.l	a0,dumptrack(a6)
			
				move.l	copfirst(a6),displaylist(a6)
				move.l	copsecond(a6),writelist(a6)
				move.w	#NUMREPEAT,numrepeat(a6)
				move.w	#2*COPOFSDELT,copofsdelt(a6)
				clr.w		framecount(a6)
			
				lea.l		floppywrite_vblank(pc),a0
				move.l	a0,vb_routine(a6)
.dontinstall:

.noggeldig:
			tst.b		TB_valid(a2)
			bne.s		.noggeldig
			
			moveq.l	#RETRIES,d3


.retry:	bsr		startread
			bsr		waitread
			tst.w		d0
			bne		.readerror
			
			bsr		checkread
			tst.w		d0
			beq.s		.goed
			dbra		d3,.retry
*			cmp.w		#SECTORERROR,d0
*			beq.s		.readerror
			bra.s		.readerror
			
.goed		st			TB_valid(a2)
			lea		trackbuffers+TRACKSINCACHE*TB_SIZEOF(a6),a0

			lea		TB_SIZEOF(a2),a2
			cmp.l		a0,a2
			blt.s		.nowrap
			lea		trackbuffers(a6),a2
.nowrap:
			addq.w	#1,d2
			cmp.w		#NUMTRACKS,d2
			bge.s		.wachttotvbklaaris
			bsr		waitvb
			bsr		gotonexttrack
			bsr		waitvb
			bra		.nexttrack
			
.wachttotvbklaaris:
			tst.l		vb_routine(a6)
			bne.s		.wachttotvbklaaris
			
			bsr		waitvb
			moveq		#EOK,d3
			bra.s		quit
			

.break:
			moveq		#EBREAK,d3
			bra.s		quit
			
.readerror:
			moveq		#EREAD,d3
			
quit:
			clr.l		vb_routine(a6)
			move.l	#cprblack,cop1lc(a5)
			bsr		waitvb

			sf.b		d2
			bsr		motor

quit1:
			bsr		cleanupfloppy
			
			move.l	d3,d0
			movem.l	(SP)+,D1-D7/A0-A6
			rts

			
floppywrite_vblank:
			movem.l	d2-d7/a2-a6,-(sp)
			lea		vars(pc),a6
			lea		$dff000,a5			
			
			cmp.w		#NUMTRACKS,dumptracknr(a6)
			blt.s		.nognietklaar
			move.l	#cprblack,cop1lc(a5)
			clr.l		vb_routine(a6)			;stap uit
			bra		.quit
.nognietklaar:

			move.l	dumptrack(a6),a1
			tst.b		TB_valid(a1)
			bne.s		.validtrack
			move.l	#cprbetween,cop1lc(a5)
			bra		.quit
			
.validtrack:
			tst.w		framecount(a6)
			bne.s		.busy
			
			move.l	TB_aftergap(a1),writepos(a6)
			move.b	#POSTGAP,writepart(a6)
			clr.b		blocknr(a6)
			move.w	#FRAMESPERTRACK,framecount(a6)
			
.busy:
				move.l	writelist(a6),a0
				move.l	dumptrack(a6),a2
				move.w	copofsdelt(a6),d0
				move.b	blocknr(a6),d1
				bsr		floppywritecopperlist

				move.l	writelist(a6),a2
				
				cmp.w		#1,framecount(a6)
				bne.s		.nietlaatsteframe
				cmp.w		#1,numrepeat(a6)
				bne.s		.nietlaatsteframe

				lea		DATAOFFSET+(BLOCKSPERFRAME-2)*BLOCKSIZE(a2),a0
				move.w	grafpage+2(a6),d0
				add.w		#TRACKSYNCOFFSET,d0
				move.w	d0,d1
				add.w		#16,d1
				bsr		fillblock
.nietlaatsteframe:			
				move.l	displaylist(a6),writelist(a6)
				move.l	a2,displaylist(a6)

				move.l	a2,cop1lc(a5)
			
			subq.w	#1,framecount(a6)
			bne.s		.quit

			sub.w		#COPOFSDELT,copofsdelt(a6)
			subq.w	#1,numrepeat(a6)
			bne.s		.quit			

			move.w	#NUMREPEAT,numrepeat(a6)
			move.w	#2*COPOFSDELT,copofsdelt(a6)
			
			move.l	dumptrack(a6),a1
			sf.b		TB_valid(a1)
			
			lea		trackbuffers+TRACKSINCACHE*TB_SIZEOF(a6),a0

			lea		TB_SIZEOF(a1),a1
			cmp.l		a0,a1
			blt.s		.nowrap
			lea		trackbuffers(a6),a1
.nowrap:
			move.l	a1,dumptrack(a6)
			addq.w	#1,dumptracknr(a6)
			
.quit:	
			movem.l	(sp)+,d2-d7/a2-a6
			rts
						
			
	
floppywritecopperlist:
* d0.w offset in copperlist d1.w blocknr eerste blok
* a0.l primary coplist 
* a2.l ptr to TB struct

			movem.l	d2-d7/a2-a4,-(a7)

			move.w	#EVENOFFSET,d3
			add.w		grafpage+2(a6),d3
			move.w	#ODDOFFSET,d4
			add.w		grafpage+2(a6),d4
	
			lea		DATAOFFSET+(BLOCKSPERFRAME*BLOCKSIZE)(a0),a1
			move.l	a1,flipadr(a6)
			lea		DATAOFFSET(a0),a1
			move.l	a1,topadr(a6)
			lea.l		crctab8(pc),a1
			lea.l		DATAOFFSET(a0,d0.w),a0
			movea.l	a2,a4
			movea.l	writepos(a6),a2
			movea.l	TB_endbuffer(a4),a3
			move.b	writepart(a6),d0
			cmp.b		#PREGAP,d0
			bne.s		.postgap
			movea.l	TB_gap(a4),a3
.postgap:
ORWAARDE	equ		$00

			moveq.l	#BLOCKSPERFRAME-1,d6
.writeblock:
*			cmp.l		#64*2,a2
*			ble		.emptyblk
			cmp.b		#WRITTEN,writepart(a6)
			beq		.emptyblk
			moveq.l	#15,d7
			move.w	d3,d0
			add.w		#HEADEROFFSET0,d0
			move.w	d0,6(a0)

			move.w	d3,6+8+8(a0)
			clr.w		d1
			move.b	blocknr(a6),d1
			addq.b	#1,blocknr(a6)
			clr.w		d0
			move.b	d1,d0
			lsl.w		#4,d0
			add.w		d4,d0
			move.w	d0,6+8+8+8(a0)
			
*			moveq		#CHECKSUMINIT,d5
*			add.b		d1,d5	
			moveq		#0,d5
*			move.b	(a1,d1.w),d5
			add.b		d1,d5
			lea		HBYTESSIZE(a0),a0
.writescanline:
			cmpa.l	a3,a2
			blt.s		.nwrittenyet

			addq.b	#1,writepart(a6)
			movea.l	TB_beginbuffer(a4),a2
			move.l	a2,d0
			bne.s		.noproblem
			move.b	#WRITTEN,writepart(a6)
			move.l	TB_aftergap(a4),a2
			bra.s		.nwrittenyet
.noproblem:
			movea.l	TB_gap(a4),a3					;>128
			
*			cmp.b		#WRITTEN,writepart(a6)
*			bne.s		.nwrittenyet
*			sub.l		a2,a2
* weggehaald: als het track afgelopen is zullen de laatste 64 bytes
*             een kopie zijn van het stuk vanaf beginbuffer
.nwrittenyet:
			moveq.l	#$55,d0
			and.b		(a2)+,d0
			moveq.l	#$55,d1
			and.b		(a2)+,d1
			add.b		d0,d0
			add.b		d1,d0
*			eor.b		d0,d5
*			move.b	(a1,d5.w),d5		
			add.b		d0,d5
						
			asl.w		#4,d0
			add.w		d3,d0
			move.w	d0,6(a0)
			
			moveq.l	#$55,d0
			and.b		(a2)+,d0
			moveq.l	#$55,d1
			and.b		(a2)+,d1
			add.b		d0,d0
			add.b		d1,d0
			
*			eor.b		d0,d5
*			move.b	(a1,d5.w),d5		
			add.b		d0,d5
			asl.w		#4,d0
			add.w		d4,d0
			move.w	d0,6+8(a0)
			
			moveq.l	#$55,d0
			and.b		(a2)+,d0
			moveq.l	#$55,d1
			and.b		(a2)+,d1
			add.b		d0,d0
			add.b		d1,d0
*			eor.b		d0,d5
*			move.b	(a1,d5.w),d5		
			add.b		d0,d5
					
			asl.w		#4,d0
			add.w		d3,d0
			move.w	d0,6+8+8(a0)
			
			moveq.l	#$55,d0
			and.b		(a2)+,d0
			moveq.l	#$55,d1
			and.b		(a2)+,d1
			add.b		d0,d0
			add.b		d1,d0
*			eor.b		d0,d5
*			move.b	(a1,d5.w),d5		
			add.b		d0,d5
					
			asl.w		#4,d0
			add.w		d4,d0
			move.w	d0,6+8+8+8(a0)
			
			lea		HBYTESSIZE(a0),a0
			dbra		d7,.writescanline

			asl.w		#4,d5
			add.w		d4,d5
			move.w	d5,-BLOCKSIZE+6+8(a0)
			bra.s		.end
.emptyblk:
			move.l	a0,a2
			move.w	d3,d0
			add.w		#EMPTYOFFSET,d0
			move.w	d0,d1
			bsr		fillblock
			lea		BLOCKSIZE(a2),a0
*			sub.l		a2,a2
.end:
			cmp.l		flipadr(a6),a0
			blt.s		.noflip
			move.l	topadr(a6),a0
.noflip:	dbra		d6,.writeblock

			move.l	a2,writepos(a6)
				
			movem.l	(a7)+,d2-d7/a2-a4
			rts
			
			

startread:  
* a2.l:ptr to trackbuf struct
			move.w	#INTF_DSKBLK,intreq(a5)

			move.w	#0,dsklen(a5)
			move.l	TB_bufadr(a2),dskpt(a5)
			move.w	#DSKF_DMAEN+(TRACKBUFSIZE/2),d0
			move.w	D0,dsklen(A5)
			move.w	D0,dsklen(A5)   ;START LEZEN

			rts
			
waitread:
			move.b	ciab+ciaicr,d0
			moveq.l	#3-1,d1			;telt indexen af
.wr		move.w	intreqr(a5),d0
			btst.l	#INTB_DSKBLK,d0
			bne.s		.ready
			btst		#CIAICRB_FLG,ciab+ciaicr
			beq		.wr		
			dbra		d1,.wr
			moveq		#-1,d0			;error
			bra.s		.eind
.ready:	moveq		#0,d0
.eind:	move.w	#0,dsklen(a5)
			rts
			
checkread:
*	a2.l: pointer to trackbuffer structure. Routine fills TB struct
* Trackbuffer structure looks like this:

*************************************************************************************
*			APTR		TB_bufadr				;points to starting address of buffer or NULL
*			APTR		TB_beginbuffer			;points first sector in buffer
*			APTR		TB_gap					;points to beginning of track gap
*			APTR		TB_aftergap				;points to first sector after gap
*			APTR		TB_endbuffer			;points just after last sector read
*			USHORT	TB_valid					;whether this track is valid.
*************************************************************************************

			movem.l	d2/d3/d4,-(SP)
			
			moveq.l	#0,d4					;returncode
			movea.l	TB_bufadr(a2),a0
			lea.l		TRACKBUFSIZE(a0),a1
			move.w	#SYNC,d3
			moveq		#SECTORSPERTRACK,d2
			cmp.w		(a0),d3
			bne		.error
			cmp.w		2(a0),d3
			beq		.goedzo
			subq.l	#2,a0
			move.w	d3,(a0)
.goedzo	move.l	a0,TB_beginbuffer(a2)
			move.l	a0,TB_aftergap(a2)		
						;misschien vind ik nu 11 sectors achter elkaar!
			clr.w		d1
.lus		cmp.w		(a0),d3
			bne.s		.foundgap
			cmp.w		2(a0),d3
			bne		.error

			bsr		checksector
			beq.s		.secok1
			moveq.l	#SUMERROR,d4
.secok1:
			addq.w	#1,d1
			lea.l		SECSIZE(a0),a0
			cmp.w		d2,d1
			blt.s		.lus
* en ja hoor, alle sectoren ineens, zonder gap ertussen!
			move.l	a0,TB_endbuffer(a2)
			move.l	a0,TB_gap(a2)
			clr.l		TB_beginbuffer(a2)
			bra.s		.foundallsectors
.foundgap:
			move.l	a0,TB_gap(a2)
			
			addq.l	#8,a0
			
.searchendofgap:
			cmp.l		a1,a0
			bge.s		.error

			cmp.w		(a0)+,d3
			bne.s		.searchendofgap
			
			cmp.w		(a0),d3
			bne.s		.enkelsync
			subq.l	#2,a0
			bra.s		.foundendofgap
.enkelsync:
			subq.l	#4,a0
			move.w	d3,(a0)
.foundendofgap:
			
			move.l	a0,TB_aftergap(a2)
.searchaftergap:				
			cmp.w		(a0),d3
			bne.s		.error
			cmp.w		2(a0),d3
			bne		.error
			bsr		checksector
			beq.s		.secok2
			moveq.l	#SUMERROR,d4
.secok2:	
			addq.w	#1,d1
			lea.l		SECSIZE(a0),a0
			cmp.w		d2,d1
			blt.s		.searchaftergap
			
			move.l	a0,TB_endbuffer(a2)
.foundallsectors:
			bra.s		.klaar
.error:
			moveq.l	#SECTORERROR,d4
.klaar:	move.l	d4,d0
			movem.l	(SP)+,d2/d3/d4
			rts


checksector:
*a0.l		pointer naar sector
*sector = 270 long words.

			movem.l	a0/d1-d7,-(SP)
			addq.l	#4,a0
			moveq		#0,d0
			moveq		#(270/6)-1,d1
.leor:
			movem.l	(a0)+,d2-d7		;6 lw
			eor.l		d2,d0
			eor.l		d3,d0
			eor.l		d4,d0
			eor.l		d5,d0
			eor.l		d6,d0
			eor.l		d7,d0
			
			dbra		d1,.leor
			
			movem.l	(SP)+,a0/d1-d7
			and.l		#$55555555,d0									
			rts
			
gototrack:
* d2.w: new track
			movem.l	d2/d3,-(a7)
			cmp.w		#NUMTRACKS,d2
			bge.s		.quit
			move.w	d2,d3
			move.b	ciabprb(a6),d0
			and.b		#~CIAF_DSKSIDE,d0
			and.w		#~1,track(a6)
			btst.l	#0,d2
			beq.s		.upper
			or.w		#1,track(a6)
			or.b		#CIAF_DSKSIDE,d0
.upper	
			move.b	d0,ciabprb(a6)
			or.b		#CIAF_DSKMOTOR,d0
			move.b	d0,ciab+ciaprb
			moveq.l	#SEEKP,d2
			sub.w		track(a6),d3
			bpl.s		.move
			moveq.l	#SEEKN,d2
			neg.w		d3
.move		subq.w	#2,d3
			bmi.s		.quit
			bsr		step
			bra.s		.move
.quit		bsr		stepdelay
			bsr		stepdelay
			bsr		stepdelay
			bsr		stepdelay
			bsr		stepdelay
			bsr		stepdelay
			bsr		stepdelay
			bsr		stepdelay
			bsr		stepdelay
			bsr		stepdelay
			bsr		stepdelay
			bsr		stepdelay
			bsr		stepdelay
			movem.l	(a7)+,d2/d3
			rts

gotonexttrack:
* no parameters
			move.l	d2,-(a7)
			lea		ciab,a0
			move.w	track(a6),d2
			addq.w	#1,d2
			cmp.w		#NUMTRACKS,d2
			bge.s		.quit
			move.w	d2,track(a6)
			move.b	ciabprb(a6),d0

			btst		#0,d2
			bne.s		.lower
			and.b		#~CIAF_DSKSIDE,d0
			move.b	d0,ciabprb(a6)
			or.b		#CIAF_DSKMOTOR|CIAF_DSKSTEP,d0
			move.b	d0,ciaprb(a0)
			moveq		#SEEKP,d2
			bsr.s		dostep

			bra.s		.quit
.lower
			or.b		#CIAF_DSKSIDE,d0
			move.b	d0,ciabprb(a6)
			or.b		#CIAF_DSKMOTOR|CIAF_DSKSTEP,d0
			move.b	d0,ciaprb(a0)
.quit
			move.l	(a7)+,d2
			rts
			
dostep:
* a0.l: ciab d2.b: direction, -2 or 2 (SEEKN or SEEKP)
			tst.w		d2
			smi.b		d0
			and.b		#CIAF_DSKDIREC,d0
			or.b		ciabprb(a6),d0
			or.b		#CIAF_DSKMOTOR|CIAF_DSKSTEP,d0
			subq.b	#CIAF_DSKSTEP,d0

			move.b	d0,ciaprb(a0)
			addq.b	#CIAF_DSKSTEP,d0
			move.b	d0,ciaprb(a0)
			rts
			
step:
* d2.b: direction, -2 or 2 (SEEKN or SEEKP)
			lea		ciab,a0
			add.w		d2,track(a6)

			bsr.s		dostep
			
			bsr.s		stepdelay
			rts
stepdelay:
			lea		ciab,a0			
			bclr		#CIACRBB_ALARM,ciacrb(a0)
			moveq		#0,d0
			move.b	d0,ciatodhi(a0)
			move.b	d0,ciatodmid(a0)
			move.b	d0,ciatodlow(a0)
			
			move.l	#120,d0
.headdelay:
			cmp.b		ciatodlow(a0),d0
			bge.s		.headdelay
			
			rts
			
motor:
* d2.b: boolean on/off
			move.b	ciabprb(a6),d0
			and.b		#~CIAF_DSKMOTOR,d0
			tst.b		d2
			bne.s		.on
			or.b		#CIAF_DSKMOTOR,d0
.on		move.b	d0,ciabprb(a6)
			move.b	d0,d1
			or.b		#CIAF_NDSKSEL,d0
			move.b	d0,ciab+ciaprb
			move.b	d1,ciab+ciaprb			
			tst.b		d2
			beq.s		.off
.wait		btst.b	#CIAB_DSKRDY,ciaa+ciapra
			bne.s		.wait
.off		rts
			
prbvalues:
			dc.b		CIAF_DSKMOTOR|CIAF_NDSKSEL0|CIAF_DSKSTEP
			dc.b		CIAF_DSKMOTOR|CIAF_NDSKSEL1|CIAF_DSKSTEP
			dc.b		CIAF_DSKMOTOR|CIAF_NDSKSEL2|CIAF_DSKSTEP
			dc.b		CIAF_DSKMOTOR|CIAF_NDSKSEL3|CIAF_DSKSTEP

_VFG_SetBuffers:
trbuf0ptr	equ	4
trbuf1ptr	equ	8
trbuf2ptr	equ	12
trbuf3ptr	equ	16
			lea.l		vars(pc),a0
			move.l	trbuf0ptr(sp),d0
			addq.l	#2,d0
			move.l	d0,trackbuffers+TB_SIZEOF*0+TB_bufadr(a0)
			move.l	trbuf1ptr(sp),d0
			addq.l	#2,d0
			move.l	d0,trackbuffers+TB_SIZEOF*1+TB_bufadr(a0)
			move.l	trbuf2ptr(sp),d0
			addq.l	#2,d0
			move.l	d0,trackbuffers+TB_SIZEOF*2+TB_bufadr(a0)
			move.l	trbuf3ptr(sp),d0
			addq.l	#2,d0
			move.l	d0,trackbuffers+TB_SIZEOF*3+TB_bufadr(a0)
			rts
			
initfloppy:
*d2.w:	drivenr
			move.l	d2,-(sp)

*			move.l	#trbuf0+2,trackbuffers+TB_bufadr(a6)
*			move.l	#trbuf1+2,trackbuffers+TB_SIZEOF*1+TB_bufadr(a6)
*			move.l	#trbuf2+2,trackbuffers+TB_SIZEOF*2+TB_bufadr(a6)
*			move.l	#trbuf3+2,trackbuffers+TB_SIZEOF*3+TB_bufadr(a6)

			move.b	#$AA,d0
			move.l	#GAPSIZE,d1
			move.l	trackbuffers+TB_bufadr(a6),a0
			move.w	#$AAAA,GAPSIZE+SECSIZE*SECTORSPERTRACK(a0)
			bsr		memset

			move.b	#$AA,d0
			move.l	#GAPSIZE,d1
			move.l	trackbuffers+TB_SIZEOF*1+TB_bufadr(a6),a0
			move.w	#$AAAA,GAPSIZE+SECSIZE*SECTORSPERTRACK(a0)
			bsr		memset
			
			move.w	#DMAF_SETCLR|DMAF_DISK,dmacon(a5)	

			move.b	#3,ciaa+ciaddra
			move.b	#$ff,ciab+ciaddrb			
			move.b	prbvalues(pc,d2.w),d0
			move.b	d0,ciab+ciaprb
			move.b	d0,ciabprb(a6)
			
			move.w	adkconr(a5),oldadkcon(a6)
			move.w	#ADKF_SETCLR|ADKF_WORDSYNC|ADKF_FAST,adkcon(A5)

			move.w	#SYNC,dsksync(A5)
			clr.w		oldtrack(a6)
*			moveq		#SEEKN,D2
*L1			btst		#CIAB_DSKTRACK0,ciaa+ciapra
*			beq.s		tr0
*			bsr		step
*			addq.w	#2,oldtrack(a6)
*			bra.s		L1
tr0		clr.w		track(a6)
*			bsr		stepdelay
*			bsr		stepdelay
*			bsr		stepdelay
*			bsr		stepdelay
			move.l	(sp)+,d2
			rts
			
cleanupfloppy:
			move.w	oldtrack(A6),D2
			bsr		gototrack
			move.w	#$7FFF,adkcon(a5)
			move.w	oldadkcon(a6),d0
			or.w		#ADKF_SETCLR,d0
			move.w	D0,adkcon(A5)

			rts

			
			
waitfire:
.wd:		btst		#CIAB_GAMEPORT0,ciaa+ciapra
			bne.s		.wd
.wu:		btst		#CIAB_GAMEPORT0,ciaa+ciapra
			beq.s		.wu
			move.l	#$A00,d0	
kaas		subq.l	#1,d0
			bne.s		kaas
			rts
			

copymem:	move.b	(a0)+,(a1)+
memcpy:
			dbra		d0,copymem
			rts

setmem:	move.b	d0,(a0)+
memset:	dbra		d1,setmem
			rts
			

;_AllocUnit:
;		move.l	_DRResource,a6
;		move.l	4(sp),d0
;		jmp	_RVOAllocUnit(a6)
;_FreeUnit:
;		move.l	_DRResource,a6
;		move.l	4(sp),d0
;		jmp	_RVOFreeUnit(a6)
_GetUnit:
		move.l	_DRResource,a6
		move.l	4(sp),a1
		jmp	_RVOGetUnit(a6)
;_GetUnitID:
;		move.l	_DRResource,a6
;		move.l	4(sp),d0
;		jmp	_RVOGetUnitID(a6)
_GiveUnit:
		move.l	_DRResource,a6
		jmp	_RVOGiveUnit(a6)


			section	bytes,DATA
			xref		EVENOFFSET,ODDOFFSET
			xref		HEADEROFFSET0,HEADEROFFSET1
			xref		BACKUPSYNCOFFSET,TRACKSYNCOFFSET,EMPTYOFFSET


			section	copper,DATA_C
			xref		cprblack,cprbetween

			end
			

