*videointerface.s
*FASTAMIGA	equ	1

			INCLUDE	"video.i"
			INCLUDE	"vbserror.i"

HBYTESSIZE	equ	44
BLOCKSIZE	equ	(17*HBYTESSIZE)
COPOFSDELT	equ	5*BLOCKSIZE

			xref		_GfxBase,_BAG_rdisplayflg

			xdef		_VBS_VIInit,_VBS_WriteBackupHeader
			xdef		_VBS_WriteMem,_VBS_RestoreScreen
			xdef		_VBS_ReadMem,_VBS_Search			
			xdef		_VBS_WriteTestPattern,_VBS_CheckPattern			
			xdef		_VBS_FindMemLimit,_VBS_CheckInterval
			xdef		_VBS_WriteErrorIndicator
			xdef		_VBS_WaitFire
			xdef		_VBS_ShowPlane,_VBS_ShowBlack
			xdef		_VBS_CheckLoopback
			xdef		_VBS_GetTimer,_VBS_ReadTimer,_VBS_FreeTimer
			xdef		_VBS_VertBServer
			xdef		_VBS_empty_pointer
			xdef		_VBS_WriteMemRS
			xdef		_VBS_ReadMemRS

			xdef		_VBS_WriteFirstBlockSync,_VBS_SearchFirstBlockSync
			xdef		_VBS_MemCmpL,_VBS_ShowCopperList
			xdef		crctab8,lsb4table,msb4table
			xdef		disable_initser,enable,vars,coppershort
			xdef		copperlong,fillblock,clearblock,shownextplane,writeblack,writesync
			xdef		waitvb,writecopperlist

_VBS_ShowCopperList:
showcopperlist:
showcopperlist_nw:



disable:
			move.l	a6,-(sp)
			move.l	4,a6
			jsr		_LVODisable(a6)
			move.l	(sp)+,a6
			st.b		disabled(a6)
			rts


disable_initser:
			bsr		disable
			move.w	#(PERIODE-1)+$8000,serper(a5)
			rts			
enable:
*			btst		#6,$bfe001
*			beq.s		enable
			move.l	a6,-(sp)
			move.l	4,a6
*			move.w	#INTF_SETCLR|INTF_MASTER,intena(a5)
			jsr		_LVOEnable(a6)
			move.l	(sp)+,a6
			clr.b		disabled(a6)
			rts

waitvb_disabled:
			move.w	#INTF_VERTB,intreq(a5)
.wvb		move.w	intreqr(a5),d0
			and.w		#INTF_VERTB,d0
			beq.s		.wvb
			move.w	#INTF_VERTB,intreq(a5)
			rts

waitvb:
			tst.b		disabled(a6)
			bne.s		waitvb_disabled
			clr.b		vb_occurred(a6)
.wvb		tst.b		vb_occurred(a6)
			beq.s		.wvb
			rts
			

_VBS_WriteBackupHeader:  ;(char *)
headerblockp	equ	4
			move.l	headerblockp(SP),d0
			
			movem.l	a2-a6/d2-d7,-(SP)
			move.l	d0,a3
			lea		$dff000,a5
			lea		vars(pc),a6

			
			move.w	#TRACKSYNC,d0
			bsr		writesync
			bsr		waitvb
			bsr		waitvb
			move.w	#HEADERSYNC0,headersync(a6)

			move.l	nextplane(a6),a0
			move.l	a3,a1
			bsr		writeheaderlist
			bsr		shownextplane
*			move.w	#TRACKSYNC,d0
*			bsr		writesync
			bsr		shownextplane 
			
			bsr		waitvb

			movem.l	(SP)+,a2-a6/d2-d7
			
			moveq.l	#0,d0
			rts
			
_VBS_WaitFire:
			movem.l	a2-a6/d2-d7,-(SP)
			lea		$dff000,a5
			lea		vars(pc),a6

			bsr		writeblack
			bsr		waitfire	

			movem.l	(SP)+,a2-a6/d2-d7
			
			moveq.l	#1,d0
			rts


clearblock:
* a0.l ptr to bitplane segment
* d1.w # scanlines
		
			moveq		#0,d0
			subq.w	#1,d1
.lus:		move.l	d0,(a0)+
			move.l	d0,(a0)+
			move.l	d0,(a0)+
			move.l	d0,(a0)+
			move.l	d0,(a0)+
			move.l	d0,(a0)+
			move.l	d0,(a0)+
			move.l	d0,(a0)+
			move.l	d0,(a0)+
			move.l	d0,(a0)+
			move.l	d0,(a0)+
			dbra		d1,.lus
			rts

fillblock:
* a0.l ptr to bitplane segment
* d0.w data to be written 9 bits
* d1.w # scanlines
			
			movem.l	d2/d3/a2/a3,-(sp)
			lea.l		lsb4table(pc),a2
			lea.l		msb4table(pc),a3

			move.w	d0,d2
			move.w	d1,d3
			add.w		d3,d3
			subq.w	#1,d3
.rept:
			move.w	d2,d0
			wrevenbyte9
			move.w	d2,d0
			wroddbyte9
			dbra		d3,.rept
			
			movem.l	(sp)+,d2/d3/a2/a3
			rts
			
writeblock:
* a0.l pointer to block in copper list/bit plane
* a1.l pointer to data

* uses blocknr(a6)
			movem.l	d2-d7/a2-a4,-(sp)
			lea.l		crctab8(pc),a4
			lea.l		lsb4table(pc),a2
			lea.l		msb4table(pc),a3

			
			move.w	headersync(a6),d0
			wrevenbyte9
			lea.l		12(a0),a0

			clr.w		d0
			move.b	blocknr(a6),d0
			move.w	d0,d5
*			move.b	(a4,d0.w),d5	
			wrevenbyte8

			clr.w		d0
			move.b	blocknr+1(a6),d0
			add.b		d0,d5
*			eor.b		d0,d5
*			move.b	(a4,d5.w),d5
			wroddbyte8

			moveq.l	#16-1,d7

.writescanline:
			clr.w		d0
			move.b	(a1)+,d0
			add.b		d0,d5
*			eor.b		d0,d5
*			move.b	(a4,d5.w),d5
			
			wrevenbyte8
			
			clr.w		d0
			move.b	(a1)+,d0
			add.b		d0,d5
*			eor.b		d0,d5
*			move.b	(a4,d5.w),d5
			
			wroddbyte8
			clr.w		d0
			move.b	(a1)+,d0
			add.b		d0,d5
*			eor.b		d0,d5
*			move.b	(a4,d5.w),d5
			
			wrevenbyte8
			
			clr.w		d0
			move.b	(a1)+,d0
			add.b		d0,d5
*			eor.b		d0,d5
*			move.b	(a4,d5.w),d5
			
			wroddbyte8
			dbra		d7,.writescanline

			move.w	d5,d0
			move.l	a0,a4
			lea.l		(-(16*44+12+10+12))(a0),a0
			wroddbyte8
			move.l	a4,a0

			movem.l	(sp)+,d2-d7/a2-a4
			rts
			
			
writeheaderlist:
* a0.l coplist a1.l ptr to disk info block

			movem.l	d2-d7/a2-a4,-(a7)

			movea.l	a1,a4
			move.l	a0,a3

			move.w	#BLOCKSPERFRAME*17,d1
			bsr		clearblock

			move.w	#BACKUPSYNC,d0
			lea		BLOCKSIZE*1(a3),a0
			moveq.l	#17,d1
			bsr		fillblock
			
			moveq		#4-1,d6
			lea		BLOCKSIZE*3(a3),a0
			move.l		a0,d7
.writebackupinfoblock:
			move.l		d7,a0
			movea.l		a4,a1
			clr.w		blocknr(a6)
			bsr		writeblock
			add.l		#BLOCKSIZE*2,d7
			dbra		d6,.writebackupinfoblock

			lea.l		BLOCKSIZE*12(a3),a0
			move.w	#TRACKSYNC,d0
			moveq.l	#17,d1
			bsr		fillblock

.quit		movem.l	(a7)+,d2-d7/a2-a4
			rts
			
_VBS_WriteMem:
memptr	equ	4
memsize	equ	8
times		equ	12

			movea.l	memptr(SP),a0
			move.l	memsize(SP),d0
			cmp.l		#64*16*50,d0
			bge.s		zeergoed
			move.l	#64*16*50,d0
zeergoed:			
			move.l	times(SP),d1
			movem.l	d2-d7/a2-a6,-(sp)
			lea.l		vars(pc),a6
			lea.l		$dff000,a5
			
			move.w	d1,d7
			subq.w	#1,d7
			move.l	a0,a2
			lea		(a0,d0.l),a3

			move.w	#TRACKSYNC,d0
			bsr		writesync
			bsr		waitvb
			bsr		waitvb
			move.w	#COPOFSDELT*2,d5
.repeat:			
			move.l	a2,writepos(a6)
			clr.w		blocknr(a6)
.nextframe:
			move.l	nextplane(a6),a0
			move.w	d5,d0
			bsr		writecopperlist
			
			bsr		shownextplane
			
			cmp.l		writepos(a6),a3
			bgt.s		.nextframe
			sub.w		#COPOFSDELT,d5
			dbra		d7,.repeat
.kaas:
			move.w	#TRACKSYNC,d0
			bsr		writesync
			moveq		#10-1,d1
.lus:		bsr		waitvb
			dbra		d1,.lus

			eor.w		#HEADERSYNC1^HEADERSYNC0,headersync(a6)
			
			movem.l	(sp)+,d2-d7/a2-a6
			moveq		#0,d0
			rts
			
_VBS_WriteTestPattern:
wtp_memptr	equ	4

			movea.l	wtp_memptr(SP),a0
			movem.l	d2-d7/a2-a6,-(sp)
			lea.l		vars(pc),a6
			lea.l		$dff000,a5
			
			move.w	#500-1,d7
			move.l	a0,a2

			move.l	a2,writepos(a6)
			clr.w		blocknr(a6)

			move.l	nextplane(a6),a0
			move.w	#0,d0
			bsr		writecopperlist
			
			bsr		shownextplane

.repeat:
			bsr		waitvb
			dbra		d7,.repeat

			move.w	#TRACKSYNC,d0
			bsr		writesync

			movem.l	(sp)+,d2-d7/a2-a6
			moveq		#0,d0
			rts
					
	
writecopperlist:
* d0.w offset in copperlist
* a0.l primary coplist 

* modifies: blocknr(a6) writepos(a6)

			movem.l	d2-d7/a2-a4,-(a7)
			lea		(BLOCKSPERFRAME*BLOCKSIZE)(a0),a3
			lea		(a0,d0.w),a4
			movea.l	writepos(a6),a2

			moveq.l	#BLOCKSPERFRAME-1,d6
.writeblock:
			movea.l	a4,a0
			movea.l	a2,a1
			bsr		writeblock
			lea		BYTESPERBLOCK(a2),a2
			lea		BLOCKSIZE(a4),a4
			cmp.l		a3,a4
			blt.s		.noflip
			lea		-BLOCKSPERFRAME*BLOCKSIZE(a3),a4
.noflip:
			addq.w	#1,blocknr(a6)
			dbra		d6,.writeblock

			move.l	a2,writepos(a6)
				
			movem.l	(a7)+,d2-d7/a2-a4
			rts
			
			
waitfire:
.wd:		btst		#CIAB_GAMEPORT0,ciaa+ciapra
			bne.s		.wd
.wu:		btst		#CIAB_GAMEPORT0,ciaa+ciapra
			beq.s		.wu
			move.l	#$A00,d0	
kaas		subq.l	#1,d0
			bne.s		kaas
			rts
			
_VBS_VIInit:
vi_plane0	equ	4
vi_plane1	equ	8
vi_view0		equ	12
vi_view1		equ	16

		movea.l	sp,a0
		movem.l	a2-a6/d2-d7,-(SP)
		lea	$dff000,a5
		lea	vars(pc),a6

		lea	byteimages12(pc),a1
		moveq	#0,d7
.doe:		move.l	#$FFF00000,(a1)
		clr.l	4(a1)
		clr.l	8(a1)
		clr.l	12(a1)
		addq.l	#1,a1
		move.b	d7,d0
		moveq	#4-1,d6
.v2bits:
		lsr.b	#1,d0
		bcs.s	.zwart1
		or.b	#$0F,(a1)
		st.b	1(a1)
.zwart1:	addq.l	#2,a1
		lsr.b	#1,d0
		bcs.s	.zwart2
		st.b	(a1)
		or.b	#$F0,1(a1)
.zwart2:	addq.l	#1,a1
		dbra	d6,.v2bits	
		addq.l	#3,a1
		addq.b	#1,d7
		bne.s	.doe

		move.l	vi_plane0(a0),actiplane(a6)
		move.l	vi_plane1(a0),nextplane(a6)
		move.l	vi_view0(a0),actiview(a6)
		move.l	vi_view1(a0),nextview(a6)
		clr.b	disabled(a6)
		clr.b	in_vb(a6)
			
		move.l	actiplane(a6),blocksok(a6) ; should be big enough don't you think?

		move.l	#nullsprite,d0
		move.w	d0,d1
		swap	d0
		lea	sprclr(PC),a0
.wegspr:	move.l	(a0)+,d2
		beq.s	.ready
		move.l	d2,a1
		moveq	#8-1,d2
.kaaslus:
		move.w	d0,2(a1)
			
		move.w	d1,6(a1)
		addq.l	#8,a1

		dbra	d2,.kaaslus
		bra.s	.wegspr
.ready:	
		movem.l	(SP)+,a2-a6/d2-d7			
		rts

sprclr:	dc.l		showpl_spritenull,0




.ready:	movem.l	(SP)+,a2-a6/d2-d7			
			rts

_VBS_RestoreScreen:
			movem.l	a5/a6,-(SP)
			lea		$dff000,a5
			lea		vars(pc),a6
			

			bsr		restorescreen
							
*			move.w	#$c000,intena(a5)
			movem.l	(sp)+,a5/a6
			moveq.l	#0,d0
			rts
			
restorescreen:
			move.l	_GfxBase,a0

			move.l	StartLijst(a0),cop1lc(a5)
			bra		waitvb
*			rts

			
copymem:	move.b	(a0)+,(a1)+
memycpy:
			dbra		d0,copymem
			rts

dataarea:	ds.b	BYTESPERBLOCK
_VBS_Search:
			movem.l	d2-d7/a2-a6,-(sp)
			
			lea.l		$dff000,a5
			lea.l		vars(pc),a6
			
			bsr		disable_initser
			bsr		coppershort
			move.w	#HEADERSYNC0,headersync(a6)
			lea		dataarea(pc),a2
			movea.l	a2,a0
			bsr		search
			tst.w		d0
			beq.s		.ok
			sub.l		a2,a2
.ok:
			bsr		copperlong
			bsr		enable
			move.l	a2,d0
			movem.l	(sp)+,d2-d7/a2-a6
			rts

search:
*a0: dataarea
			movem.l	d2-d7/a2-a4,-(sp)

			lea.l		crctab8(pc),a2
			lea.l		serdatr(a5),a4
			lea.l		$bfe001,a3
			move.w	#INTF_RBF,d3
			
			move.w	d3,intreq(a5)
			bra.s		.again0
.break:
			moveq		#2,d0
			clr.l		(a0)
			bra		.quit

.again0:	moveq		#6,d6
			move.w	#$1FF*2,d7
.bs:
			move.w	(a4),d0
			btst.b	d6,(a3)
			beq.s		.break
			add.w		d0,d0
			bpl.s		.bs
			move.w	d3,intreq(a5)
			and.w		d7,d0
			cmp.w		#BACKUPSYNC*2,d0
			bne.s		.bs

.find20:	move.w	#5,d1
.bs0:
			move.w	(a4),d0
			add.w		d0,d0
			bpl.s		.bs0
			move.w	d3,intreq(a5)

			and.w		d7,d0
			cmp.w		#BACKUPSYNC*2,d0
			bne.s		.again0
			dbra		d1,.bs0

			move.w	d3,intreq(a5)
			sf.b		second_time(a6)

.readblk:moveq		#14,d7
.hs0:
			move.w	(a4),d0
			btst		d7,d0
			beq.s		.hs0
			move.w	d3,intreq(a5)
			and.w		#$1FF,d0
*			cmp.w		#ERRORSYNC,d0
*			beq		.error
			cmp.w		#HEADERSYNC0,d0
			bne.s		.hs0

.checksum:
			move.w	(a4),d5
			btst.l	d7,d5
			beq.s		.checksum
			move.w	d3,intreq(a5)
			clr.w		d1
			move.b	d5,d1
			swap		d1
			clr.w		d5
								
			moveq		#0,d0
.blocknr0:
			move.w	(a4),d5
			btst.l	d7,d5
			beq.s		.blocknr0
			move.w	d3,intreq(a5)

.blocknr1:
			move.w	(a4),d1
			btst.l	d7,d1
			beq.s		.blocknr1
			move.w	d3,intreq(a5)

			add.b		d1,d5
			movea.l	a0,a1
			
			moveq		#BYTESPERBLOCK-1,d6
.readbytes:
			move.w	(a4),d0
			btst.l	d7,d0
			beq.s		.readbytes
			move.w	d3,intreq(a5)
			add.b		d0,d5
			move.b	d0,(a1)+
			dbra		d6,.readbytes

			swap		d1
			cmp.b		d1,d5
			beq.s		.again1
			
			addq.b		#1,second_time(a6)
			cmp.b		#4,second_time(a6)
			bne.s		.readblk

.error:	clr.l		(a0)
			moveq		#1,d0
			bra.s		.quit
			
.again1:	moveq		#5,d1
			move.w	#$1FF*2,d7
.bs1:
			move.w	(a4),d0
			add.w		d0,d0
			bpl.s		.bs1
			move.w	d3,intreq(a5)

			and.w		d7,d0
			cmp.w		#TRACKSYNC*2,d0
			bne.s		.again1
			
			dbra		d1,.bs1
			moveq		#0,d0
.quit:			
			movem.l	(sp)+,d2-d7/a2-a4
			rts



writeblack:
			move.l	nextplane(a6),a0
			move.w	#17*BLOCKSPERFRAME,d1
			bsr		clearblock
			bra		shownextplane

writesync:
* D0: sync value to write
			movem.l	d2,-(sp)
			move.l	d0,d2
			
			move.l	nextplane(a6),a0
			move.w	#17*BLOCKSPERFRAME,d1
			move.w	d2,d0
			bsr		fillblock
			bsr		shownextplane
			movem.l	(sp)+,d2
			rts
			
shownextplane:
			tst.b		in_vb(a6)
			bne.s		.invb
			bsr		disable
			clr.b		vb_occurred(a6)			
			move.l	nextview(a6),a1
			move.l	_GfxBase,a6
			jsr		_LVOLoadView(a6)
			lea.l		vars(pc),a6
			bsr		enable
.wvb:		tst.b		vb_occurred(a6)
			beq.s		.wvb
			bra.s		.exchange
			
.invb:	move.l	nextview(a6),a1
			move.l	_GfxBase,a6
			jsr		_LVOLoadView(a6)
			lea.l		vars(pc),a6
			
.exchange:
			move.l	actiview(a6),d0
			move.l	nextview(a6),actiview(a6)
			move.l	d0,nextview(a6)
			move.l	actiplane(a6),d0
			move.l	nextplane(a6),actiplane(a6)
			move.l	d0,nextplane(a6)
			rts			
			
_VBS_WriteErrorIndicator:
			movem.l	d2-d7/a2-a6,-(sp)
			lea		$dff000,a5
			lea		vars(pc),a6
			move.w	#ERRORSYNC,d0
			bsr		writesync
			
			move.w	#50*3-1,d6
.writeerrorframe:
			bsr		waitvb
			dbra		d6,.writeerrorframe
			bsr		writeblack
			movem.l	(sp)+,d2-d7/a2-a6
			moveq		#0,d0
			rts

coppershort:		*fast list: minimum instructions
			move.l	d2,-(sp)
			bsr		waitvb_disabled
			move.w	_BAG_rdisplayflg,d2
			btst		#0,d2
			beq.s		.niet68000
			
			move.l	#cprshowplshort,cop1lc(a5)
			move.w	#0,copjmp1(a5)
			move.w	#$9000,bplcon0(a5)
			move.w	#DMAF_SPRITE,dmacon(a5)			
.niet68000:
			btst		#1,d2
			beq.s		.nietchip
			bsr		waitvb_disabled
			move.w	#DMAF_COPPER+DMAF_RASTER+DMAF_SPRITE,dmacon(a5)
.nietchip:
			move.l	(sp)+,d2
			rts
			
copperlong:
			move.l	d2,-(sp)
			bsr		waitvb_disabled
			move.w	_BAG_rdisplayflg,d2
			btst		#0,d2
			beq.s		.niet68000
			move.l	#cprshowpl,cop1lc(a5)
			move.w	#0,copjmp1(a5)
			move.w	#DMAF_SETCLR+DMAF_SPRITE,dmacon(a5)
.niet68000:
			btst		#1,d2
			beq.s		.helemaalnix
			bsr		waitvb_disabled
			move.w	#DMAF_SETCLR+DMAF_RASTER+DMAF_COPPER+DMAF_SPRITE,dmacon(a5)
.helemaalnix:
			move.l	(sp)+,d2
			rts			

_VBS_ReadMem:
rm_memptr	equ	4
rm_memsize	equ	8

			move.l	rm_memptr(sp),a0
			move.l	rm_memsize(sp),d0
			movem.l	d2-d7/a2-a6,-(sp)
			
			lea		$dff000,a5
			lea		vars(pc),a6
			lea.l		crctab8(pc),a2
			move.l	a0,a3
			move.l	d0,d3
			bsr		disable_initser
			
			bsr		coppershort	
			
			
			move.l	a3,a0
			move.l	d3,d0
			
			move.l	d0,d4
			move.l	d0,d1
			add.l		#%111111,d1
			lsr.l		#6,d1
			move.w	d1,d7			;nblocksnok(a6)

			addq.w	#3,d1
			lsr.w		#2,d1			;(nblocks+3) div 4

			movea.l	blocksok(a6),a3
			movea.l	a3,a1
.fillzero:
			clr.l		(a1)+
			dbra		d1,.fillzero
			
			lea.l		serdatr(a5),a4
			move.w	#INTF_RBF,d3
			move.w	d3,intreq(a5)
			move.w	#$FFFF,d6;breakval(a6)		impossible value
			move.w	#100,track(a6)
.hs0:
			move.w	(a4),d0
.hsq:
			btst		#14,d0
			beq.s		.hs0
			move.w	d3,intreq(a5)
			and.w		#$1FF,d0
*			cmp.w		#ERRORSYNC,d0
*			beq		.valuefound
			cmp.w		d6,d0;breakval(a6),d0
			beq		.valuefound
			cmp.w		headersync(a6),d0
			bne.s		.hs0

.checksum:
			move.w	(a4),d5
			btst.l	#14,d5
			beq.s		.checksum
			move.w	d3,intreq(a5)
			clr.w		d1
			move.b	d5,d1
			swap		d1
*			move.w	#TRACKSYNC,breakval(a6)
						
			moveq		#0,d0
.blocknr0:
			move.w	(a4),d0
			btst.l	#14,d0
			beq.s		.blocknr0
			move.w	d3,intreq(a5)
			clr.w		d5
			move.b	d0,d5
			lsl.w		#8,d0
.blocknr1:
			move.w	(a4),d1
			btst.l	#14,d1
			beq.s		.blocknr1
			move.w	d3,intreq(a5)
			add.b		d1,d5
			
			move.b	d1,d0
			move.w	d0,d2
			
			asl.l		#6,d0
			cmp.l		d4,d0
			bhs.s		.hs0
			
			tst.b		(a3,d2.w)
			bne.s		.hs0
*		move.w	#$FF0,color(a5)
			
			lea.l		(a0,d0.l),a1
			
			swap		d2
			move.w	#(BYTESPERBLOCK/4)-1,d2
			move.w	#14,d1
.readbytes:
			move.w	(a4),d0
			btst.l	d1,d0
			beq.s		.readbytes
			move.w	d3,intreq(a5)
			add.b		d0,d5
*			eor.b		d0,d5
*			move.b	(a2,d5.w),d5
			move.b	d0,(a1)+
.rb1:
			move.w	(a4),d0
			btst.l	d1,d0
			beq.s		.rb1
			move.w	d3,intreq(a5)
			add.b		d0,d5
			move.b	d0,(a1)+
.rb2:
			move.w	(a4),d0
			btst.l	d1,d0
			beq.s		.rb2
			move.w	d3,intreq(a5)
			add.b		d0,d5
			move.b	d0,(a1)+
.rb3:
			move.w	(a4),d0
			btst.l	d1,d0
			beq.s		.rb3
			move.w	d3,intreq(a5)
			add.b		d0,d5
			move.b	d0,(a1)+
			dbra		d2,.readbytes
	
			swap		d2
			swap		d1
			cmp.b		d1,d5
*		sne		d0
*		ext.w		d0
*		move.w	d0,color(a5)
			bne		.hs0
			st.b		(a3,d2.w)
			subq.w	#1,d7				;nblocksnok(a6)
			beq		.chunkread
			subq.w	#1,track(a6)
			bne		.hs0
			move.w	#TRACKSYNC,d6;breakval(a6)
			move.w	(a4),d0
			bra		.hsq
.chunkread:			
			eor.w		#HEADERSYNC0^HEADERSYNC1,headersync(a6)
			moveq		#EOK,d2
			tst.w		d7					;nblocksnok(a6)
			beq.s		.quit
			bne.s		.errorfound
			
.valuefound:
			moveq		#10-1,d2
.readb:
			move.w	(a4),d1
			btst		#14,d1
			beq.s		.readb
			move.w	d3,intreq(a5)
			and.w		#$1FF,d1
			cmp.w		d0,d1
			bne		.hs0
			dbra		d2,.readb
			cmp.w		#TRACKSYNC,d0
			beq.s		.chunkread
.errorfound:			
			moveq		#EOK+0*EVIDEOREAD,d2
.quit:		
			bsr		copperlong
			
			bsr		enable
			move.l	d2,d0
			movem.l	(sp)+,d2-d7/a2-a6
			rts				

_VBS_CheckPattern:
cp_memptr		equ	4
cp_memsize		equ	8
cp_errspecpt	equ	12
es_blocks		equ 	0
es_bytes			equ	4
es_zeros			equ	8
es_ones			equ	12

			move.l	cp_memptr(sp),a0
			move.l	cp_memsize(sp),d0
			move.l	cp_errspecpt(sp),a1

			movem.l	d2-d7/a2-a6,-(sp)
			
			lea		$dff000,a5
			lea		vars(pc),a6
			clr.w		blocknr(a6)
			clr.w		nblocksnok(a6)
			
			move.l	a1,errspecpt(a6)
			lea.l		(a0,d0.l),a3
			
			lea.l		crctab8(pc),a2
			move.l	a0,d3
			move.l	d0,d4
			bsr		disable_initser
			
			move.w	#DMAF_COPPER|DMAF_RASTER,dmacon(a5)
*			bsr		coppershort	
			
			
			move.l	d3,a0
			move.l	d4,d0
			
			lea.l		serdatr(a5),a4
			moveq.l	#0,d0
			moveq.l	#0,d1
			moveq.l	#0,d2
			moveq.l	#0,d3
			moveq.l	#0,d4			aantal 0->1
			moveq.l	#0,d5	
			moveq.l	#0,d6
			moveq.l	#0,d7
			move.l	d0,a1			aantal 1->0
			
			
			move.w	#INTF_RBF,d3
			move.w	d3,intreq(a5)
			move.w	#$FFFF,breakval(a6)		impossible value

.hs0:
			move.w	(a4),d0
			btst		#14,d0
			beq.s		.hs0
			move.w	d3,intreq(a5)
			and.w		#$1FF,d0
*			cmp.w		#ERRORSYNC,d0
*			beq		.valuefound
			cmp.w		breakval(a6),d0
			beq		.valuefound
			cmp.w		headersync(a6),d0
			bne.s		.hs0

.checksum:
			move.w	(a4),d5
			btst.l	#14,d5
			beq.s		.checksum
			move.w	d3,intreq(a5)
			clr.w		d1
			move.b	d5,d1
			swap		d1
			move.w	#TRACKSYNC,breakval(a6)
						
			moveq		#0,d0
.blocknr0:
			move.w	(a4),d0
			btst.l	#14,d0
			beq.s		.blocknr0
			move.w	d3,intreq(a5)
			clr.w		d5
			and.w		#$FF,d0
			move.b	(a2,d0),d5
.blocknr1:
			move.w	(a4),d1
			btst.l	#14,d1
			beq.s		.blocknr1
			move.w	d3,intreq(a5)
			eor.b		d1,d5
			move.b	(a2,d5.w),d5
			ext.w		d1
			lsl.w		#6,d1
			lea		(a0,d1.w),a3
			
			clr.w		d1
			moveq		#BYTESPERBLOCK-1,d7
			moveq		#0,d2
.readbytes:
			move.w	(a4),d0
			btst.l	#14,d0
			beq.s		.readbytes
			move.w	d3,intreq(a5)
			eor.b		d0,d5
			move.b	(a2,d5.w),d5
			move.b	(a3)+,d1
		
*			ifd		FASTAMIGA
*			
*			move.b	d1,d2
*			not.b		d1
*			and.b		d0,d1
*			not.b		d0
*			and.b		d2,d0
*			and.w		#$FF,d0
*			
*			move.b	.aantalenen(pc,d1.w),d2	;aantal 0->1
*			add.l		d2,d4
*			move.b	.aantalenen(pc,d0.w),d2 ;aantal 1->0
*			add.l		d2,a1
*			
*			endc
			
			eor.b		d0,d1
			sne.b		d2
			neg.b		d2
			add.l		d2,d6
			
			dbra		d7,.readbytes
*			bra		.verder
*.aantalenen:			
*			dc.b  0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4
*			dc.b  2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5
*			dc.b  2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4
*			dc.b  2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6
*			dc.b  2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6
*			dc.b  4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5
*			dc.b  2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5
*			dc.b  3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7
*			dc.b  2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6
*			dc.b  4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7
*			dc.b  4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
*.verder:
			swap		d1
			cmp.b		d1,d5
			sne.b		d2
			neg.b		d2
			add.w		d2,nblocksnok(a6)			;aantal foute blokken
			addq.w	#1,blocknr(a6)				;totaal gelezen
			bra		.hs0
			
.valuefound:
			moveq		#10-1,d2
.readb:
			move.w	(a4),d1
			btst		#14,d1
			beq.s		.readb
			move.w	d3,intreq(a5)
			and.w		#$1FF,d1
			cmp.w		d0,d1
			bne		.hs0
			dbra		d2,.readb
*			cmp.w		#TRACKSYNC,d0
*			beq.s		.chunkread

.quit:		
*			bsr		copperlong
			move.w	#DMAF_SETCLR|DMAF_COPPER|DMAF_RASTER,dmacon(a5)
			
			bsr		enable
			move.l	errspecpt(a6),a0
			move.w	nblocksnok(a6),d0
			move.l	d0,es_blocks(a0)
			ifd		FASTAMIGA
			move.l	d4,es_zeros(a0)
			move.l	a1,es_ones(a0)
			endc
			move.l	d6,es_bytes(a0)			
			move.w	blocknr(a6),d0
			ext.l		d0
			movem.l	(sp)+,d2-d7/a2-a6
			rts				



_VBS_CheckInterval:
ci_start	equ		4
ci_len	equ		8

			moveq.l	#0,d0
			move.l	ci_len(sp),d1
			beq.s		.zerolength
			move.l	ci_start(sp),d0
			
			add.l		d0,d1
			subq.l	#1,d1
			lsr.l		#6,d1
			
			lsr.l		#6,d0
			sub.l		d0,d1
			movea.l	d0,a0
			lea		vars(PC),a1
			add.l		blocksok(a1),a0
			
.test:	tst.b		(a0)+
			dbeq		d1,.test

			seq.b		d0
			ext.w		d0
			ext.l		d0
.zerolength:
			rts
			
_VBS_FindMemLimit:
			move.l	blocksok+vars(PC),a0
			moveq.l	#-64,d0
			moveq.l	#64,d1
.test		add.l		d1,d0
			tst.b		(a0)+
			bne.s		.test
			rts
		
		
_VBS_ShowBlack:
			movem.l	a5/a6,-(sp)
			lea.l		vars(pc),a6
			lea		$dff000,a5
			bsr		writeblack
			movem.l	(sp)+,a5/a6
			rts

_VBS_WriteFirstBlockSync:
			movem.l	a5/a6,-(sp)
			lea		vars(pc),a6
			move.w	#FIRSTBLOCKSYNC,d0
			bsr		writesync
			move.w	#TRACKSYNC,d0
			bsr		writesync
			movem.l	(sp)+,a5/a6
			rts

_VBS_SearchFirstBlockSync:
			movem.l	d2-d7/a2-a6,-(sp)
			
			lea.l		$dff000,a5
			lea.l		vars(pc),a6
			
			bsr		disable_initser
			bsr		coppershort
			lea.l		serdatr(a5),a4
			lea.l		$bfe001,a3
			moveq		#6,d6
			move.w	#INTF_RBF,intreq(a5)

.again0:
.bs:
			move.w	(a4),d0
			btst.b	d6,(a3)
			beq.s		.break
			add.w		d0,d0
			bpl.s		.bs

			move.w	#INTF_RBF,intreq(a5)
			bra.s		.find20
.break:
			moveq		#-1,d0
			bra		.quit

.find20:
			move.w	#20,d1
.bs0:
			move.w	(a4),d0
			add.w		d0,d0
			bpl.s		.bs0
			move.w	#INTF_RBF,intreq(a5)

			and.w		#$1FF*2,d0
			cmp.w		#FIRSTBLOCKSYNC*2,d0
			bne.s		.again0
			dbra		d1,.bs0

.ok:
			
			bsr		copperlong
			bsr		enable
			moveq.l	#0,d0
.quit:
			movem.l	(sp)+,d2-d7/a2-a6
			rts

		
_VBS_ShowPlane:
sp_plane		equ		4
sp_width		equ		8
sp_height	equ		12
sp_dxoffset	equ		16
sp_dyoffset	equ		20
sp_modes		equ		24
sp_color0	equ		28
sp_color1	equ		32

			move.l	sp,a0		
			movem.l	d2-d7/a2-a6,-(sp)
		
			lea		$dff000,a5
			lea		vars(pc),a6
		
			move.l	sp_color0(a0),d0
			move.w	d0,showpl_color0+2
			move.l	sp_color1(a0),d0
			move.w	d0,showpl_color1+2
			move.l	sp_plane(a0),d0
			move.w	d0,showpl_plptl+2
			move.w	d0,showpls_plptl+2
			swap		d0
			move.w	d0,showpl_plpth+2
			move.w	d0,showpls_plpth+2
			move.l	sp_modes(a0),d1
			move.w	d1,showpl_bplcon0+2
			and.w		#$8000,d1			;HIRES
			beq.s		.lores
.hires:	move.l	sp_dxoffset(a0),d1
			sub.w		#9,d1
			moveq		#7,d4
			and.w		d1,d4
			lsr.w		#1,d1
			and.w		#$fffc,d1
			move.l	sp_width(a0),d2
			move.w	d2,d3
			lsr.w		#1,d3
			lsr.w		#2,d2
			sub.w		#8,d2
			add.w		d1,d2
			bra.s		.datafetch
.lores:	move.l	sp_dxoffset(a0),d1
			sub.w		#17,d1
			moveq		#15,d4
			and.w		d1,d4
			lsr.w		#1,d1
			and.w		#$fff8,d1
			move.l	sp_width(a0),d2
			move.w	d2,d3
			lsr.w		#1,d2
			sub.w		#8,d2
			add.w		d1,d2
.datafetch:
			move.w	d4,d0
			lsl.w		#4,d0
			or.w		d4,d0
			move.w	d0,showpl_bplcon1+2
			move.w	d1,showpl_ddfstrt+2
			move.w	d2,showpl_ddfstop+2
			move.l	sp_dyoffset(a0),d0
			lsl.w		#8,d0
			move.l	sp_dxoffset(a0),d1
			move.b	d1,d0
			move.w	d0,showpl_diwstrt+2

			move.l	sp_dyoffset(a0),d0
			add.l		sp_height(a0),d0
*			and.l		#$ff,d0
			lsl.w		#8,d0
			add.w		d3,d1
			move.b	d1,d0
			move.w	d0,showpl_diwstop+2

			move.l	sp_dyoffset(a0),d0
			add.l		sp_height(a0),d0
			move.b	d0,d1
			lsl.w		#8,d1
			add.w		#61,d1
			move.w	#1,showpl_cwait1
			cmp.w		#256,d0
			blt.s		.laag
			move.w	#$FFDF,showpl_cwait1
.laag:	move.w	d1,showpl_cwait2

			move.l	#cprshowpl,cop1lc(a5)

			movem.l	(sp)+,d2-d7/a2-a6
			moveq		#0,d0
			rts

_VBS_CheckLoopback:

			movem.l	d2-d7/a2-a6,-(sp)
			lea		$dff000,a5
			lea		vars(pc),a6

			
			move.w	#TRACKSYNC,d0
			bsr		writesync
			bsr		disable_initser

*wwww:
*			btst #6,$bfe001
*			beq.s wwww
*wwww2:
*			btst #6,$bfe001
*			bne.s wwww2

			bsr		waitvb
			bsr		waitvb
			lea.l		serdatr(a5),a4
			move.w	#INTF_RBF|INTF_VERTB,intreq(a5)

			moveq		#0,d2			;FALSE
			move.w	#INTF_RBF,d3

			move.w	#2*$1ff,d5

			moveq		#100,d4
.bs0:
			move.w	(a4),d0
			moveq		#INTF_VERTB,d1
			and.w		intreqr(a5),d1
			bne.s		.error
			add.w		d0,d0
			bpl.s		.bs0
;			move.w	d0,(a3)+
			move.w	d3,intreq(a5)
			dbra		d4,.bs0

			move.w	#500,d4
.bs1:
			move.w	(a4),d0
			moveq		#INTF_VERTB,d1
			and.w		intreqr(a5),d1
			bne.s		.error
			add.w		d0,d0
			bpl.s		.bs1
;			move.w	d0,(a3)+
			move.w	d3,intreq(a5)
			and.w		d5,d0
			cmp.w		#TRACKSYNC*2,d0
			bne.s		.error
			dbra		d4,.bs1
			moveq		#1,d2
.error:
			bsr		enable
			bsr		writeblack
			
			move.l	d2,d0
			movem.l	(sp)+,d2-d7/a2-a6
			rts

_VBS_VertBServer:
			lea		vars(pc),a0
			addq.l	#1,countvertb(a0)
			st.b		vb_occurred(a0)
			st.b		in_vb(a0)
			move.l	vb_routine(a0),d0
			beq.s		.noroutine
			move.l	d0,a1
			jsr		(a1)
.noroutine:
			sf.b		vars+in_vb
			moveq.l	#0,d0			;set Z-bit: continue to process other vb-servers
			rts

_VBS_GetTimer:
*			lea		ciaa,a0			
*			bset		#CIACRBB_ALARM,ciacrb(a0)
*			move.b	#$4,ciaicr(a0)
			rts
			
_VBS_ReadTimer:
*			lea		ciaa,a0			
*			moveq		#0,d0
*			move.b	ciatodhi(a0),d0
*			swap		d0
*			move.b	ciatodmid(a0),d0
*			lsl.w		#8,d0
*			move.b	ciatodlow(a0),d0
			move.l	vars+countvertb(pc),d0
			rts

_VBS_FreeTimer:
*			lea		ciaa,a0			
*			bclr		#CIACRBB_ALARM,ciacrb(a0)
*			move.b	#$84,ciaicr(a0)
			rts


_VBS_MemCmpL:
cmpl_p0	equ		4
cmpl_p1	equ		8
cmpl_nl	equ		12

	move.l	cmpl_nl(sp),d0
	move.l	cmpl_p1(sp),a1
	move.l	cmpl_p0(sp),a0

	moveq	#3,d1
	and.w	d0,d1
	lsr.l	#2,d0
	subq.w	#1,d0
	bcs.s	next64kl
nextlw:	cmpm.l	(a0)+,(a1)+
	dbne	d0,nextlw
	bne.s	foutcmp
next64kl:	
	sub.l	#$10000,d0
	bcc.s	nextlw
	subq.w	#1,d1
	bcs.s	nukl
nextbyte:	
	cmpm.b	(a0)+,(a1)+
	dbne	d1,nextbyte
	bne.s	foutcmp
nukl:	
	moveq	#0,d0
	rts
foutcmp:	
	moveq	#-1,d0
	rts

	ifd OUDJES

			
			moveq	#-1,d0
			moveq	#7,d2
			and.l	d1,d2
			beq.s	dovgl8
			subq.w	#1,d2
vglw:			cmpm.l	(a0)+,(a1)+
			dbeq	d2,vglw
			bne.s	cmpquit
dovgl8:			
			lsr.l	#3,d1
			beq.s	cmpready
			subq.w	#1,d1
vgl8:			cmpm.l	(a0)+,(a1)+
			bne.s	cmpquit
			cmpm.l	(a0)+,(a1)+
			bne.s	cmpquit
			cmpm.l	(a0)+,(a1)+
			bne.s	cmpquit
			cmpm.l	(a0)+,(a1)+
			bne.s	cmpquit
			cmpm.l	(a0)+,(a1)+
			bne.s	cmpquit
			cmpm.l	(a0)+,(a1)+
			bne.s	cmpquit
			cmpm.l	(a0)+,(a1)+
			bne.s	cmpquit
			cmpm.l	(a0)+,(a1)+
			dbeq	d1,vgl8
			bne.s	cmpquit
cmpready:		moveq	#0,d0
cmpquit:	move.l	(sp)+,d2
			rts


	ENDC

blk	ds.b	RSBLOCKHDRSIZE+RSBLOCKSIZE+RSBLOCKTRAILERSZ
	even

rscopylinestoscr:	
; a0 dest, a1 src d0 len

	movem.l	a2/a3,-(sp)
	lea	byteimages12(pc),a2
	subq.w	#1,d0
	bmi.s	.einde
.regel:			
	moveq	#0,d1
	move.b	(a1)+,d1
	lsl.w	#4,d1
	lea	0(a2,d1.w),a3
	move.l	(a3)+,(a0)+
	move.l	(a3)+,(a0)+
	move.l	(a3)+,(a0)+
	move.w	(a3)+,(a0)+
	clr.b	(a0)+
;	addq.l	#1,a0

	moveq	#0,d1
	move.b	(a1)+,d1
	lsl.w	#4,d1
	lea	0(a2,d1.w),a3
	move.l	(a3)+,(a0)+
	move.l	(a3)+,(a0)+
	move.l	(a3)+,(a0)+
	move.w	(a3)+,(a0)+
	clr.b	(a0)+
;	addq.l	#1,a0

	moveq	#0,d1
	move.b	(a1)+,d1
	lsl.w	#4,d1
	lea	0(a2,d1.w),a3
	move.l	(a3)+,(a0)+
	move.l	(a3)+,(a0)+
	move.l	(a3)+,(a0)+
	move.w	(a3)+,(a0)+
	dbra	d0,.regel
.einde:	movem.l	(sp)+,a2/a3
	rts

rsclrscrlines:
	subq.w	#1,d0
	bmi.s	.g
.regel			
	moveq	#11-1,d1
.c	clr.l	(a0)+
	dbra	d1,.c
	dbra	d0,.regel
.g			
	rts			


ChunkHdrBytes:
	dc.b	$81,$85,$89,$91,$a1,$b7,$33,$aa,$AA
	dc.b	0

_VBS_WriteMemRS:
wmrs_offset	equ	4+4*(6+5)
wmrs_length	equ	8+4*(6+5)
wmrs_addr	equ	12+4*(6+5)
wmrs_lognumcw	equ	16+4*(6+5)
wmrs_shiftregt	equ	20+4*(6+5)
wmrs_modulotab	equ	24+4*(6+5)

	movem.l	d2-d7/a2-a6,-(sp)
	lea	vars(PC),a6
	lea	$dff000,a5
			
	move.l	rmrs_modulotab(sp),a2
	move.l	rmrs_lognumcw(sp),d2

	moveq	#1,d0
	lsl.l	d2,d0
	move.l	d0,numcw(a6)
		
	move.l	a2,a1
	moveq	#0,d0
	moveq	#(N-K),d1
	lsl.l	d2,d1
	move.l	d1,numcw_x_n_m_k(a6)
	lsr.l	#2,d1	;/4
	subq.w	#1,d1
.clrloop:
	move.l	d0,(a1)+
	dbra	d1,.clrloop

	move.w	#3-1,d5
.rep:			
	lea	blk(pc),a1
	move.l	#$45454545,9(a1)
	move.l	#$45454545,13(a1)
	move.w	#1,d6
	cmp.w	#1,d5
	bne.s	.neen1
	move.l	wmrs_offset(sp),9(a1)
	move.l	wmrs_length(sp),13(a1)
	moveq	#3,d6
.neen1:			
	move.l	ChunkHdrBytes(pc),(a1)+
	move.l	ChunkHdrBytes+4(pc),(a1)+
	move.b	ChunkHdrBytes+8(pc),(a1)+

	move.b	(a1)+,d0
	add.b	(a1)+,d0
	add.b	(a1)+,d0
	add.b	(a1)+,d0
	add.b	(a1)+,d0
	add.b	(a1)+,d0
	add.b	(a1)+,d0
	add.b		(a1)+,d0
	move.b	d0,(a1)+
	
	move.l	nextplane(a6),a0
			
	moveq	#VIDEOHEIGHT/8-1,d7
.wh:	moveq	#(9+8+1)/RSBYTESPERLINE,d0
	lea	blk(pc),a1
	bsr	rscopylinestoscr
	moveq	#2,d0
	bsr	rsclrscrlines
	dbra	d7,.wh

	moveq	#VIDEOHEIGHT&7,d0
	bsr	rsclrscrlines
				
	bsr	shownextplane
	subq.w	#1,d6
	bmi.s	.gav
.show:	bsr	waitvb
	dbra	d6,.show
.gav:			
	dbra	d5,.rep


	clr.w	blocknum(a6)
	clr.w	blockinframe(a6)
	lea	blk+6(pc),a4
	move.w	#RSBLOCKSIZE,d5
	move.l	nextplane(a6),a0
	moveq	#1,d0
	bsr	rsclrscrlines
	move.l	a0,curscraddr(a6)
	
	move.l	wmrs_addr(sp),a0

	moveq	#0,d6		;telt tot K
.l2:			
	move.l	numcw(a6),d7
	subq.l	#1,d7
	
	move.w	d6,d0
	addq.w	#1,d0
	and.w	#15,d0
	lea.l	0(a2,d0.w),a1
	move.l	d6,d0
	addq.w	#2,d0
	lsl.w	#6,d0
	lsl.w	#6,d0	;shiftregtab is 64k!!
	add.l	wmrs_shiftregt(sp),d0
	move.l	d0,a3
.l1:	
	moveq	#0,d0
	move.b	(a0)+,d0
	move.b	d0,(a4)+
	move.b	(a1),d1
	clr.b	(a1)
	eor.b	d1,d0
	lsl.w	#4,d0
	movem.l	0(a3,d0.w),d1-d4
	eor.l	d1,(a2)+
	eor.l	d2,(a2)+
	lea.l	16(a1),a1
	eor.l	d3,(a2)+
	eor.l	d4,(a2)+
	
	subq.w	#1,d5
	beq.s	.l3
	dbra	d7,.l1
	sub.l	numcw_x_n_m_k(a6),a2
	addq.w	#1,d6
	cmp.w	#K,d6
	bne.s	.l2
	bra.s	.l5
.l3:	move.l	a0,d5
	move.l	a1,d4
	bsr	nextblock
	move.l	d5,a0
	move.l	d4,a1
	addq.w	#1,blocknum(a6)
	move.w	#RSBLOCKSIZE,d5
	lea	blk+6(pc),a4

	dbra	d7,.l1
	sub.l	numcw_x_n_m_k(a6),a2
	addq.w	#1,d6
	cmp.w	#K,d6
	bne.s	.l2
	

.l5:
	move.l	wmrs_modulotab(sp),a2
	move.w	#N-K-1,d7
.c2:		
	move.l	numcw(a6),d6
	subq.l	#1,d6
.c1:		
	move.b	(a2),(a4)+
	lea	16(a2),a2
	subq.w	#1,d5
	beq.s	.c3
	dbra	d6,.c1
	sub.l	numcw_x_n_m_k(a6),a2
	addq.l	#1,a2
	dbra	d7,.c2
	
	bsr	nextblock	;finish up
	addq.w	#1,blocknum(a6)
	bra.s	.c5
.c3:	bsr	nextblock
	addq.w	#1,blocknum(a6)
	move.w	#RSBLOCKSIZE,d5
	lea	blk+6(pc),a4
	dbra	d6,.c1
	sub.l	numcw_x_n_m_k(a6),a2
	addq.l	#1,a2
	dbra	d7,.c2
.c5:	
	move.w	#(RSBLOCKSIZE/2)-1,d5
	lea	blk+6(pc),a4
	move.w	#$5555,d0
.kip	move.w	d0,(a4)+
	dbra	d5,.kip

	moveq	#2,d2
.schrb			
	tst.w	blockinframe(a6)
	bne.s	1$
	subq.w	#1,d2
	beq.s	.echtkl
1$	
	bsr	nextblock
	bra	.schrb
.echtkl:			
	movem.l	(sp)+,d2-d7/a2-a6
	moveq	#0,d0
	rts
			
			
nextblock:
*	move.w	#$ff0,color(a5)
	move.l	curscraddr(a6),a0			
	lea	blk(pc),a1
	move.w	blocknum(a6),d1
	eor.b	#BH0,d1
	move.b	d1,(a1)
	eor.b	#BH0^BH1,d1
	move.b	d1,1(a1)
	eor.b	#BH1^BH2,d1
	move.b	d1,2(a1)
	eor.b	#BH2^BH3,d1
	move.b	d1,3(a1)
	eor.b	#BH3^BH4,d1
	move.b	d1,4(a1)
	eor.b	#BH4^BH5,d1
	move.b	d1,5(a1)
	move.b	#$44,6+RSBLOCKSIZE(a1)
	move.b	#$44,6+RSBLOCKSIZE+1(a1)
	move.b	#$44,6+RSBLOCKSIZE+2(a1)
	move.w	#(6+RSBLOCKSIZE+3)/RSBYTESPERLINE,d0
	bsr	rscopylinestoscr
	addq.w	#1,blockinframe(a6)
	cmp.w	#RSBLOCKSPERFRAME,blockinframe(a6)
	beq.s	.newframe
	moveq	#2,d0
	bsr	rsclrscrlines
	move.l	a0,curscraddr(a6)
*	move.w	#$000,color(a5)
	rts
.newframe
*	move.w	#$f00,color(a5)
	bsr	shownextplane
	move.l	nextplane(a6),a0
	moveq	#VIDEOHEIGHT-RSHEIGHT,d0
	bsr	rsclrscrlines
	move.l	a0,curscraddr(a6)
	
	clr.w	blockinframe(a6)
	rts
			
waitf:			
1$	btst		#6,$bfe001
	bne.s		1$
	move.w	#$f000,d0
3$	nop	
	nop
	dbra		d0,3$			
2$	btst		#6,$bfe001
	beq.s		2$
	rts			

waitemptyline: ;in: a5 custom
	lea	$bfd000,a0
		
	move.b	$e00(a0),d0
	or.b	#%1000,d0
	and.b	#~%100001,d0
	move.b	d0,d1
	addq.b	#1,d1
.opnieuw:			
	move.w	#INTF_RBF,intreq(a5)
	move.b	d0,$e00(a0)
	move.b	#45,$400(a0)
	move.b	#00,$500(a0)
	move.b	d1,$e00(a0)	;start timer
.wachtopeinde:			
	btst.b	#6,serdatr(a5)	;bit 14 van serdatr
	bne.s	.opnieuw
	btst.b	#0,$e00(a0)
	bne.s	.wachtopeinde
	rts
			

readchunkhdr: ;in: a0 desiredoffset
	movem.l	d2-d7/a2-a6,-(sp)
	lea	$dff000,a5
	lea	vars(pc),a6
	lea.l	serdatr(a5),a4
	lea	$bfe001,a3
			
	move.w	#INTF_RBF,d3
	move.l	a0,a2
.kloptniet:			
	bsr	waitemptyline

	moveq	#9-1,d7
	lea	ChunkHdrBytes(pc),a1
.r:	move.w	(a4),d0
	btst	#6,(a3)
	beq.s	.break
	btst	#14,d0
	beq.s	.r
	move.w	d3,intreq(a5)
	cmp.b	(a1)+,d0
	bne.s	.kloptniet
	dbra	d7,.r
		
	moveq	#8-1,d7
	lea	offset(a6),a1
	clr.b	d1
.s:	move.w	(a4),d0
	btst	#6,(a3)
	beq.s	.break
	btst	#14,d0
	beq.s	.s
	move.w	d3,intreq(a5)
	add.b		d0,d1
	move.b	d0,(a1)+
	dbra		d7,.s
.t:	move.w	(a4),d0
	btst		#6,(a3)
	beq.s		.break
	btst		#14,d0
	beq.s		.t
	move.w	d3,intreq(a5)
	cmp.b		d0,d1
	bne.s		.kloptniet
	move.l	offset(a6),a0
	move.l	length(a6),d1
	moveq		#EENCOUNTERED45,d0
	cmp.l		#$45454545,a0
	bne.s		.geen45
	cmp.l		d1,a0
	beq.s		.einde
.geen45:
	cmp.l	#$1000000,d1
	bhs.s	.kloptniet
		
	moveq		#EWRONGCHUNK,d0
	cmp.l		a0,a2
	blo.s		.einde
	lea		(a0,d1.l),a1
	cmp.l		a1,a2
	bhs.s		.einde
	moveq		#EOK,d0
.einde:	movem.l	(sp)+,d2-d7/a2-a6
	rts			
.break:	moveq		#0,d1
	move.l	d1,a0
	moveq		#EBREAK,d0
	bra.s		.einde

RegArray ds.l	N*2				

_VBS_ReadMemRS:
rmrs_offset		equ	4+4*(6+5)
rmrs_length		equ	8+4*(6+5)
rmrs_addr		equ	12+4*(6+5)
rmrs_lognumcw	equ	16+4*(6+5)
rmrs_shiftregt	equ	20+4*(6+5)
rmrs_modulotab	equ	24+4*(6+5)
	movem.l	d2-d7/a2-a6,-(sp)
	
	lea	$dff000,a5
	lea	vars(pc),a6

	bsr	disable
;	move.w	#DMAF_RASTER|DMAF_COPPER|DMAF_MASTER,dmacon(a5)
	move.w	#(6-1),serper(a5)
	
	bsr	coppershort	
	moveq	#1,d0
	move.l	rmrs_lognumcw(sp),d1
	lsl.l	d1,d0
	move.l	d0,numcw(a6)
	mulu.w	#N,d0
	add.l	rmrs_addr(sp),d0
	move.l	d0,topadr(a6)
	
	move.l	rmrs_modulotab(sp),a1
	moveq	#0,d0
	moveq	#(N-K),d2
	lsl.l	d1,d2
	move.l	d2,numcw_x_n_m_k(a6)
	lsr.l	#2,d2	;/4
	subq.w	#1,d2
.dclrloop:
	move.l	d0,(a1)+
	dbra	d2,.dclrloop


	
.niethetzelfde:			
	move.l	rmrs_offset(sp),a3
	move.l	(a3),d4
.again			
	move.l	d4,a0
	bsr	readchunkhdr
	cmp.w	#EENCOUNTERED45,d0
	beq.s	.again
			
	move.l	a0,a2
	move.l	d1,d2
	move.l	a2,(a3)
	move.l	rmrs_length(sp),a3
	move.l	d2,(a3)
	tst.l	d0
	bne	.quit

	move.l	d4,a0
	bsr	readchunkhdr
	cmp.l	a0,a2
	bne.s	.niethetzelfde
	cmp.l	d1,d2
	bne.s	.niethetzelfde

	move.w	#4*RSHEIGHT/8/2-1,d7
.heelveel:			
	move.l	a2,a0
	bsr	readchunkhdr
	cmp.w	#EENCOUNTERED45,d0
	beq	.quit
	cmp.w	#EBREAK,d0
	beq	.quit
	cmp.l	a0,a2
	bne.s	.heelveel
	cmp.l	d1,d2
	bne.s	.heelveel
	dbra	d7,.heelveel

	lea	RegArray(PC),a0
	move.l	a0,regdata(a6)
	moveq	#0,d4
	move.l	rmrs_modulotab(sp),a2

.vulreg:	
	move.l	d4,d0
	addq.w	#1,d0	;kies beginshift zdd eindres meteen goed is!
	and.w	#15,d0
	lea	0(a2,d0.w),a1
	move.l	d4,d0
	addq.w	#2,d0
	lsl.w	#6,d0
	lsl.w	#6,d0	;shiftregtab is 64k!!
	move.l	d0,a4
	add.l	rmrs_shiftregt(sp),a4
	move.l	a1,(a0)+
	move.l	a4,(a0)+
	addq.l	#1,d4
	cmp.w	#N,d4
	bne.s	.vulreg

	moveq	#-1,d7		;curblknr
	moveq	#0,d4		;codeword number
	moveq	#0,d5		;ctr within cw
	move.l	rmrs_addr(sp),a0
	move.l	a0,a3	
	
		
	move.w	#3,raarcnt(a6)
	move.w	#3,samecnt(a6)
	bra.s	.nextblk

.same:	moveq	#EWRONGCHUNK,d0;+18
	subq.w	#1,samecnt(a6)
	beq	.quit
	bra.s	.nextblk
.raar:	moveq	#EWRONGCHUNK,d0;+10
	subq.w	#1,raarcnt(a6)
	beq	.quit
.nextblk:
;	move.w	#0,color(a5)
	clr.l	bhsr(a6)
	move.l	a0,d2
	move.l	a1,d3
	bsr	waitemptyline
	move.l	d2,a0
	move.l	d3,a1
	move.w	#17-1,d6
.testbrk:
	btst	#6,$bfe001
	beq	.breakerr
.shiftreg:			
	move.w	serdatr(a5),d3
	btst	#14,d3
	beq.s	.testbrk
	move.w	#INTF_RBF,intreq(a5)
	movem.w	bhsr+1(a6),d0-d2
	move.b	d3,d2
	eor.w	#((BH0^BH1)<<8)|(BH1^BH2),d0
	eor.w	#((BH2^BH3)<<8)|(BH3^BH4),d1
	eor.w	#((BH4^BH5)<<8)|(BH5),d2
	movem.w	d0-d2,bhsr(a6)
	cmp.w	d0,d1
	beq.s	.gelijk
	cmp.w	d0,d2
	beq.s	.gelijk
	exg	d0,d2
	cmp.w	d0,d1
	beq.s	.gelijk
	dbra	d6,.shiftreg
	bra.s	.nextblk
.gelijk:		
	move.w	d0,d1
	lsr.w	#8,d0
	cmp.b	d0,d1
	beq.s	.gevo
	dbra	d6,.shiftreg
	bra.s	.nextblk
.gevo:		
	sub.b	d7,d0
	beq	.same
	
;	move.w	#$FF0,color(a5)

;	move.w	#3,samecnt(a6); gebeurt verderop
	cmp.b	#1+2,d0
	bhi	.raar		;meer dan 2 ertussenuit?
	add.w	d0,d7		;bits 8-15 reeds 0 door lsr.w #8,d0!!
	adda.w	.a3incrtab(pc,d0.w*2),a3

	move.l	#RSBLOCKSIZE,d1
	move.l	topadr(a6),d6
	sub.l	a3,d6
	bcs	.klaar
	cmp.l	d1,d6
	bls.s	.laatsteb
	move.w	d1,d6
.laatsteb:			
	subq.w	#1,d6
.readbytes:
	move.w	serdatr(a5),d0
	btst.l	#14,d0
	beq.s	.readbytes
	move.w	#INTF_RBF,intreq(a5)
	move.b	d0,(a3)+
	
	subq.w	#1,d5
	bpl.s	.verder
	
	movem.l	([regdata,a6]),a1/a4
	addq.l	#2*4,regdata(a6)
	move.l	rmrs_modulotab(sp),a2
	move.l	numcw(a6),d5
	subq.w	#1,d5
	addq.l	#1,d4
.verder:	
	moveq	#0,d0
	move.b	(a1),d0
	move.b	(a0)+,(a1)
	lsl.w	#4,d0
	movem.l	0(a4,d0.w),d0-d3
	eor.l	d0,(a2)+
	eor.l	d1,(a2)+
	lea.l	16(a1),a1
	eor.l	d2,(a2)+
	eor.l	d3,(a2)+

	dbra	d6,.readbytes
	move.w	#3,samecnt(a6)
	cmp.l	topadr(a6),a3
	blo	.nextblk
	bra.s	.klaar
.a3incrtab:
	dc.w	0,0,RSBLOCKSIZE,RSBLOCKSIZE*2,RSBLOCKSIZE*3


.klaar	; finish modulo calculations (if block(s) missed)	
;	move.l	d4,$f0004
;	move.l	d5,$f0008
;	move.l	a0,$f000c
;	move.l	a3,$f0010
.lus:
	subq.w	#1,d5
	bpl.s	.verder2
.lus2:
	cmp.w	#N,d4
	beq.s	.echtklaar
	movem.l	([regdata,a6]),a1/a4
	addq.l	#2*4,regdata(a6)
	move.l	rmrs_modulotab(sp),a2
	move.l	numcw(a6),d5
	subq.w	#1,d5
	addq.l	#1,d4

.verder2:	
	moveq	#0,d0
	move.b	(a1),d0
	move.b	(a0)+,(a1)
	lsl.w	#4,d0
	movem.l	0(a4,d0.w),d0-d3
	eor.l	d0,(a2)+
	eor.l	d1,(a2)+
	lea.l	16(a1),a1
	eor.l	d2,(a2)+
	eor.l	d3,(a2)+
	dbra	d5,.verder2
	bra.s	.lus2

.echtklaar:
	cmp.l	a0,a3
	beq.s	.great
	move.l	#2000000,d0
.xxxx	
	move.w	#$ff0,color(a5)
	subq.l	#1,d0
	bne.s	.xxxx
.great:	
	moveq	#EOK,d0
.quit:	move.l	d0,d2
	bsr	copperlong
	
	bsr	enable
;	move.w	#DMAF_SETCLR|DMAF_RASTER|DMAF_COPPER|DMAF_MASTER,dmacon(a5)
	
	move.l	d2,d0
	movem.l	(sp)+,d2-d7/a2-a6
	rts				
.breakerr:
	moveq		#EBREAK,d0
	bra.s		.quit


						
	cnop		0,4			
byteimages12:
			ds.l		256*4
lsb4table:
			incbin	"incbin/lsb4table"
msb4table:
			incbin	"incbin/msb4table"


crctab8:
			incbin	"incbin/crctab8"

					
vars:		ds.b		VARIABLES_SIZEOF
			
			section	bytes,DATA
			xdef		EVENOFFSET,ODDOFFSET		
			xdef		TRACKSYNCOFFSET,BACKUPSYNCOFFSET
			xdef		HEADEROFFSET0,HEADEROFFSET1
			xdef		EMPTYOFFSET
						

evenbytes:
EVENOFFSET			equ		*-evenbytes
						incbin	"incbin/evenbytes"

ODDOFFSET			equ		*-evenbytes
						incbin	"incbin/oddbytes"

HEADEROFFSET0		equ		*-evenbytes
		;0x02 0xCC met 9e bit ook wit
						dc.b		$FF,$FF,0,$FF,$FF,$FF,$FF,$FF,$FF,$FF,0,0,0,0,0,0
HEADEROFFSET1		equ		*-evenbytes
						dc.b		$FF,$FF,$FF,0,0,$FF,$FF,0,0,$FF,0,0,0,0,0,0

BACKUPSYNCOFFSET	equ		*-evenbytes
		;0x33 met 9e bit ook wit
						dc.b		$FF,0,0,$ff,$ff,0,0,$ff,$ff,$ff,0,0,0,0,0,0
						dc.b		0,$FF,0,0,$ff,$ff,0,0,$ff,$ff,$ff,0,0,0,0,0

TRACKSYNCOFFSET	equ		*-evenbytes
		;0x55 met 9e bit ook wit
						dc.b		$FF,0,$ff,0,$ff,0,$ff,0,$ff,$ff,0,0,0,0,0,0
						dc.b		0,$FF,0,$ff,0,$ff,0,$ff,0,$ff,$ff,0,0,0,0,0

EMPTYOFFSET			equ		*-evenbytes
						ds.w		16

CHIPSIZE				equ	*-evenbytes
evenbytes2:			;kopie van voorafgaande
						incbin	"incbin/evenbytes"
						incbin	"incbin/oddbytes"
						dc.b		$FF,$FF,0,$FF,$FF,$FF,$FF,$FF,$FF,$FF,0,0,0,0,0,0
						dc.b		$FF,$FF,$FF,0,0,$FF,$FF,0,0,$FF,0,0,0,0,0,0

		;0x33 met 9e bit ook wit
						dc.b		$FF,0,0,$ff,$ff,0,0,$ff,$ff,$ff,0,0,0,0,0,0
						dc.b		0,$FF,0,0,$ff,$ff,0,0,$ff,$ff,$ff,0,0,0,0,0
		;0x55 met 9e bit ook wit
						dc.b		$FF,0,$ff,0,$ff,0,$ff,0,$ff,$ff,0,0,0,0,0,0
						dc.b		0,$FF,0,$ff,0,$ff,0,$ff,0,$ff,$ff,0,0,0,0,0
						ds.w		16
						
betweenblocks:		;4 keer 0x55 met 9e bit ook wit
						dc.b		$FF,0,$ff,0,$ff,0,$ff,0,$ff,$ff,0
						dc.b		$FF,0,$ff,0,$ff,0,$ff,0,$ff,$ff,0
						dc.b		$FF,0,$ff,0,$ff,0,$ff,0,$ff,$ff,0
						dc.b		$FF,0,$ff,0,$ff,0,$ff,0,$ff,$ff,0

BETWEENSIZE			equ		*-betweenblocks

errorindicator:	;4 keer 0x66 met 9e bit ook wit
						dc.b		$FF,$ff,0,0,$ff,$ff,0,0,$ff,$ff,0
						dc.b		$FF,$ff,0,0,$ff,$ff,0,0,$ff,$ff,0
						dc.b		$FF,$ff,0,0,$ff,$ff,0,0,$ff,$ff,0
						dc.b		$FF,$ff,0,0,$ff,$ff,0,0,$ff,$ff,0

ERRORINDSIZE		equ		*-errorindicator

firstblock: 		;4 keer 0x44 met 9e bit ook wit
						dc.b		$FF,$ff,$ff,0,$ff,$ff,$ff,0,$ff,$ff,0
						dc.b		$FF,$ff,$ff,0,$ff,$ff,$ff,0,$ff,$ff,0
						dc.b		$FF,$ff,$ff,0,$ff,$ff,$ff,0,$ff,$ff,0
						dc.b		$FF,$ff,$ff,0,$ff,$ff,$ff,0,$ff,$ff,0

FIRSTBLOCKSIZE		equ		*-firstblock

			section	copper,DATA_C
_VBS_empty_pointer:	dc.w		0,0
 dc.w 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 dc.w 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 			dc.w		0,0
nullsprite:		dc.w		$fe00,$ff00,0,0,0,0

cprshowpl:
			CMOVE		0,bplpt+2
showpl_spritenull:
			CMOVE		999,sprpt
			CMOVE		999,sprpt+2
			CMOVE		999,sprpt+4
			CMOVE		999,sprpt+6
			CMOVE		999,sprpt+8
			CMOVE		999,sprpt+10
			CMOVE		999,sprpt+12
			CMOVE		999,sprpt+14
			CMOVE		999,sprpt+16
			CMOVE		999,sprpt+18
			CMOVE		999,sprpt+20
			CMOVE		999,sprpt+22
			CMOVE		999,sprpt+24
			CMOVE		999,sprpt+26
			CMOVE		999,sprpt+28
			CMOVE		999,sprpt+30
			CWAIT		0,12
			CWAIT		0,$1B

showpl_color0:
			CMOVE		999,color
showpl_color1:
			CMOVE		999,color+2
showpl_diwstrt:
			CMOVE		HSTART|(VSTART<<8),diwstrt
			CMOVE		0,bplcon0
			CMOVE		$24,bplcon2
showpl_diwstop:
			CMOVE		((HSTART+WIDTH)&255)|(((VSTART+17*BLOCKSPERFRAME)&255)<<8),diwstop

showpl_ddfstrt:
			CMOVE		(((HSTART-9)/2)&$FFF8),ddfstrt
showpl_ddfstop:
			CMOVE		(((HSTART-9)/2)&$FFF8)+(WIDTH/2)-8,ddfstop
showpl_bplcon1:
			CMOVE		$0000,bplcon1
			CMOVE		0,bpl1mod
			CMOVE		0,bpl2mod
showpl_plpth:
			CMOVE		0,bplpt
showpl_plptl:
			CMOVE		0,bplpt+2
			CWAIT		0,$1C

showpl_bplcon0:
			CMOVE		$9000,bplcon0
			
showpl_cwait1:
			CWAIT		$de,255
showpl_cwait2:
			CWAIT		60,(VSTART+17*BLOCKSPERFRAME)&255
			CMOVE		0,bplcon0
			CWAIT		255,255

cprshowplshort:
showpls_plpth:
			CMOVE		0,bplpt
			CWAIT		20,3
showpls_plptl:
			CMOVE		0,bplpt+2
			CWAIT		255,255
			
			end
			

